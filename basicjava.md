


## 多线程总结
 thread.setName(“设置一个线程名称”);这是一种规范，在创建线程完成以后，都需要设置名称。
 
 
 ### 线程池
 SychronousQueue
 1：插入操作必须等待另一个线程的的删除，删除操作必须等待另一个线程的插入操作
 如put插入然后等待另一个线程的take或poll  take 移除元素等待等待另一个线程put或add操作，等到对应操作后实现transfer，传给相应的消费者
 2：容量为0，并没有任何元素插入到队列当中


为什么单线程池和固定线程池使用的任务阻塞队列是LinkedBlockingQueue()，而缓存线程池使用的是SynchronousQueue()呢？
因为单线程池和固定线程池中，线程数量是有限的，因此提交的任务需要在LinkedBlockingQueue队列中等待空余的线程；而缓存线程池中，线程数量几乎无限（上限为Integer.MAX_VALUE），因此提交的任务只需要在SynchronousQueue队列中同步移交给空余线程即可。
 
 
## JVM 


## Java基础
int的自动装箱都是通过Integer.valueOf()方法来实现的，Integer的自动拆箱都是通过integer.intValue来实现的。缓存支持-128到127之间的自动装箱过程


Java的反射就是利用上面第二步加载到jvm中的.class文件来进行操作的。.class文件中包含java类的所有信息，当你不知道某个类具体信息时，可以使用反射获取class，然后进行各种操作。

Java反射就是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；并且能改变它的属性。总结说：反射就是把java类中的各种成分映射成一个个的Java对象，并且可以进行操作。