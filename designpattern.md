

## [模版方法模式](https://blog.csdn.net/reed1991/article/details/87561398)
所谓模版方式模式：把不变的行为搬到超类，去除子类中重复的代码来体现他的优势；当不变的和可变的行为在子类实现中混合在一起的时候，
不变的行为就会在子类中重复实现，我们通过模板方法模式把这些行为搬移到单一的地方，这样就可以帮助子类摆脱重复不变行为的纠缠。

## [策略模式](https://blog.csdn.net/reed1991/article/details/53425500)
策略模式封装了一系列的方法，并且他们可以相互替代，这些方法独立于客户端的变化而变化。

## [观察者模式](https://blog.csdn.net/reed1991/article/details/87564030)
观察者：有个接收被观察者通知的方法。
被观察者：(1)定义观察者的集合，并定义针对集合的添加、删除操作，用于增加、删除观察者
       （2）定义通知方法，用于将新情况通知给观察者

## 为什么枚举可以实现单例
枚举中所有的对象都是static final的，表明只能被实例化一次
明确构造方法为私有的
为外界提供唯一的接口来获取这个方法

## 哪些设计模式可以增加系统的可扩展性
工厂模式

抽象工厂模式

观察者模式：很方便增加观察者，方便系统扩展

模板方法模式：很方便的实现不稳定的扩展点，完成功能的重用

适配器模式：可以很方便地对适配其他接口

代理模式：可以很方便在原来功能的基础上增加功能或者逻辑

责任链模式：可以很方便得增加拦截器/过滤器实现对数据的处理，比如struts2的责任链

策略模式：通过新增策略从而改变原来的执行策略


模板模式：就是基类封装好了业务逻辑，抽象出了不稳定的部分，让子类来实现，
策略模式：将变化的部分抽象成策略，通过替换不同的策略来完成业务逻辑处理的变化，比如超时活动价格策略

适配器模式：将现有的功能转换成已经给定的接口实现，比如：jdbc的适配器模式，jdbc定义好操作模式，不同的db针对jdbc来做不同的适配
观察者模式：listener模式，将操作反向依赖到变化的事物上，例如：Spring的ApplicationEvent


[spring中用到的设计模式](https://blog.csdn.net/renxing521/article/details/80614612)