项目背景：爱奇艺QLB团队基于LVS和Nginx改造了负载均衡器。本部门提供一套管理平台用来更便捷的操作负载均衡器。
需求：最主要的工作肯定就是在管理平台填写相关的一些参数。管理平台调用底层接口生成相应的实例。然后也会提供一些接口供公司其他部门使用。
具体做法：先和负责底层的团队定义好接口。然后通过一系列参数的拼装组成JSON部署给底层。
说一下其中的一些业务点。和我们怎么去匹配这个业务。

首先对于一个负载均衡实例。是有可能好几个人都有权限去修改的。存在并发修改的问题，
1.项目是分布式部署的。所以采用synchronized这种方式加锁是无效的。基于redis实现分布式锁来处理这个问题。

redission实现分布式锁，
lua脚本，先看看key是否存在，不存在将自己的信息，写入key，并设置一些自己的信息。
存在的话，看看key里面存储的是不是自己的信息，这就是可重入锁。
看门狗机制。一旦加锁成功，就会启动一个watch dog看门狗，他是一个后台线程，会每隔10秒检查一下，如果客户端1还持有锁key，那么就会不断的延长锁key的生存时间。
锁互斥机制：如果信息已被解锁，返回key的时间。进入一个while循环，不停地尝试加锁。

先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止由于程序crash等原因没有释放。最后线程操作结束之后，释放分布式锁。

还可以用zk来做
（1）创建一个目录mylock；
（2）线程A想获取锁就在mylock目录下创建临时顺序节点；
（3）获取mylock目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁；
（4）线程B获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点；
（5）线程A处理完，删除自己的节点，线程B监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。

当时不想引入新的中间件就直接用zk做的

redis实现分布式锁的性能更好，redis是纯内存服务。
 zk的可靠性更好

1、为了防止A将B的修改覆盖掉。
用了数据库的乐观锁。部署之前会和数据库中的版本进行比对。


2、一次操作的实例有删除，有新增，有修改的。 底层是不能讲其一次性处理。
如果首先就新增的话，万一中途失败，再进行此操作就存在重复添加的问题了。删除和更新是天然幂等的。


由于七层集群和四层集群还有计算集群之间有对应的联系，此次操作可能涉及到七层集群的director发生改变，应通知到和此七层集群关联的四层集群和计算集群做出相应的联动.用的rabbitMQ来进行解耦。因为并发量不是很高，不需要用kafka。 采用的是订阅模式。
但此时存在一个问题。如果计算集群或者四层集群有个失败，重传的话会存在上次成功的那个重复消费。所以这地方给每个消息都加了一个id。消费之前判断下此id是否已消费过。


比如删除一个四层集群及其下面的业务。需要通知业务方。需要发送很多邮件，线程池异步发送，网络问题可能会出现意外，可以用消息队列异步。




工程宕机过一次。然后看线上的监控信息发现线上的内存使用一路飙高，最后产生了内存泄漏。
再测试环境进行压测，也测一段时间后用jmap -dump:format=b,file=文件名 [pid] 生成一份dump文件。
最后用mat进行分析，发现公司封装的连接cassandra的包有问题。。连接cassandra的实例他们用一个map来存储。但是map的key用的
classname+mappingmannager.hashcode()。导致产生非常多的连接实例。不断的积累导致最后内存泄漏了。


我们也提供一些接口给公司内部使用。比如我们会提供已经授权的在微软那边用户的信息给公司其他部门使用。
我们一个客户的管理员授权以后，就相当于我们可以去微软那边获取这个公司的所有员工在微软那边的信息。
信息是包含很多的。微软是以一些分散的接口返回给我们。比如我们还要获取他们的manager的信息。一次大概获取100个用户的信息。由于获取manager信息微软接口做了限制，一次只能获取20条。导致一个api响应时间大概需要5S。最后相当于开线程异步执行。响应时间降低到了4S左右，也算是一个提升了。


更多的是一些业务逻辑的东西。比如你可以预定一个会议，或者一个连续的会议。



比如说在OutLook上预定一个会议。流程是这样的。数据被写进outlook。然后outloook会将meeting的Id传给我们。
在这里用到了kafka。通常消息队列的作用是异步、解耦、削峰。但我们这里主要是为了防止在后面的流程出了意外，导致
Outlook给我们的消息丢了。
我们再通过id去微软那边拉取数据，存到自己的数据库。


OutlookMeeting和GoogleMeeting大致流程都是一样的。 都是参数校验，然后用这些参数去组装成一些对象。最后将这些信息透传下去。
所以这里使用模板方法来完成的。将固定的放在超类里面。  一些有差别的放在抽象类里。在子类中去实现它。

比如邀请的人有拒绝了，谷歌那边会直接将其过滤，微软那边则是将其状态置位declined。

会议模板信息：比如能不能在会议开始之前加会议。
site信息：toB的业务，每一个客户可能在不同的site
seriesMeeting 系列会议。有个标识

还有就是不管OutLookMeeting还是GoogleMeeting，都会有两类meeting。分别是普通的meeting和PMRmeeting两大类。
处理方式有差异。这就导致在逻辑中很多地方需要判断是普通的meeting还是PMRmeeting。为了避免这种判断。将普通的meeting和PMRmeeting作为两类service。分别去继承父类接口meetingHandler。
这样在调用的地方就可以以一个map的形式将这些接口都加入Map<String, Strategy> map。然后通过map.get("serviceName")就可以去获取到底调哪个接口。      策略模式
