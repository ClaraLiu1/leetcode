项目背景：爱奇艺QLB团队基于LVS和Nginx改造了负载均衡器。本部门提供一套管理平台用来更便捷的操作负载均衡器。
需求：最主要的工作肯定就是在管理平台填写相关的一些参数。管理平台调用底层接口生成相应的实例。然后也会提供一些接口供公司其他部门使用。
具体做法：先和负责底层的团队定义好接口。然后通过一系列参数的拼装组成JSON部署给底层。
说一下其中的一些业务点。和我们怎么去匹配这个业务。

首先对于一个负载均衡实例。是有可能好几个人都有权限去修改的。存在并发修改的问题，
1.项目是分布式部署的。所以采用synchronized这种方式加锁是无效的。基于redis实现分布式锁来处理这个问题。

先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止由于程序crash等原因没有释放。最后线程操作结束之后，释放分布式锁。

还可以用zk来做
（1）创建一个目录mylock；
（2）线程A想获取锁就在mylock目录下创建临时顺序节点；
（3）获取mylock目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁；
（4）线程B获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点；
（5）线程A处理完，删除自己的节点，线程B监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。

当时不想引入新的中间件就直接用zk做的

redis实现分布式锁的性能更好，redis是纯内存服务。
 zk的可靠性更好

为了防止A将B的修改覆盖掉。
用了数据库的乐观锁。部署之前会和数据库中的版本进行比对。


一次操作的实例有删除，有新增，有修改的。  删除 更新 添加幂等性
假如在某个环节失败了，继续点击保存。删除操作是天然幂等的。
更新由于我这次更新的信息。
如果首先就新增的话就存在重复添加的问题了。


由于七层集群和四层集群还有计算集群之间有对应的联系，此次操作可能涉及到七层集群的director发生改变，应通知到和此七层集群关联的四层集群和计算集群做出相应的联动.用的rabbitMQ来进行解耦。因为并发量不是很高，不需要用kafka。 采用的是订阅模式。
但此时存在一个问题。如果计算集群或者四层集群有个失败，重传的话会存在上次成功的那个重复消费。所以这地方给每个消息都加了一个id。消费之前判断下此id是否已消费过。


比如删除一个四层集群及其下面的业务。需要通知业务方。




工程宕机过一次。然后看线上的监控信息发现线上的内存使用一路飙高，最后产生了内存泄漏。
再测试环境进行压测，也测一段时间后用jmap -dump:format=b,file=文件名 [pid] 生成一份dump文件。
最后用mat进行分析，发现公司封装的连接cassandra的包有问题。。连接cassandra的实例他们用一个map来存储。但是map的key用的
classname+mappingmannager.hashcode()。导致产生非常多的连接实例。不断的积累导致最后内存泄漏了。


我们也提供一些接口给公司内部使用。比如我们会提供已经授权的在微软那边用户的信息给公司其他部门使用。
我们一个客户的管理员授权以后，就相当于我们可以去微软那边获取这个公司的所有员工在微软那边的信息。
信息是包含很多的。微软是以一些分散的接口返回给我们。比如我们还要获取他们的manager的信息。一次大概获取100个用户的信息。由于获取manager信息微软接口做了限制，一次只能获取20条。导致一个api响应时间大概需要5S。最后相当于开线程异步执行。响应时间降低到了4S左右，也算是一个提升了。


更多的是一些业务逻辑的东西。比如你可以预定一个会议，或者一个连续的会议。



比如说在OutLook上预定一个会议。流程是这样的。数据被写进outlook。然后outloook会将meeting的Id传给我们。
在这里用到了RabbitMQ。通常消息队列的作用是异步、解耦、削峰。但我们这里主要是为了防止在后面的流程出了意外，导致
Outlook给我们的消息丢了。
我们再通过id去微软那边拉取数据，存到自己的数据库。


OutlookMeeting和GoogleMeeting大致流程都是一样的。 都是参数校验，然后用这些参数去组装成一些对象。最后将这些信息透传下去。
所以这里使用模板方法来完成的。将固定的放在超类里面。  一些有差别的放在抽象类里。在子类中去实现它。

还有就是不管OutLookMeeting还是GoogleMeeting，都会有两类meeting。分别是普通的meeting和PMRmeeting两大类。
处理方式有差异。这就导致在逻辑中很多地方需要判断是普通的meeting还是PMRmeeting。为了避免这种判断。将普通的meeting和PMRmeeting作为两类service。分别去继承父类接口meetingHandler。
这样在调用的地方就可以以一个map的形式将这些接口都加入Map<String, Strategy> map。然后通过map.get("serviceName")就可以去获取到底调哪个接口。      策略模式
