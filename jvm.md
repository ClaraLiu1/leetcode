## 加载器的种类

String这种   启动类加载器  jre/lib/rt.jar

扩展类加载器   jre/lib/ext/*.jar

自己写的     应用类加载器

。           自定义加载器

## 类加载器工作机制

1.装载：将Java二进制代码导入jvm中，生成Class文件。

2. 连接过程

　　（1）验证：确保被加载类的正确性，即确保被加载的类符合javac编译的规范

　　（2）准备：为类的静态变量分配内存，并初始化为默认值

　　（3）解析：将类中的符号引用转化为直接引用

　　 注：符号引用即一个Java源文件在被编译时，在不清楚被引用类实际内存地址的情况下，会使用能唯一识别并定位到目标的符号来代替。如A类引用了B类，编译时A并不知道B类实际的内存地址，故可以使用能唯一识别B的符号来代替。而当类加载时，编译后的.class文件实际已被调入内存，可知道A,B类的实际内存地址，当引用的目标已被加载入内存，则此时的引用为直接引用。

3.初始化

　初始化过程为类的静态变量赋予正确的初始值（与连接过程的准备阶段不同，如int类型的静态变量，JVM的默认值为0，遇到static int a = 3的代码时，准备阶段首先是赋值为0，初始化阶段才赋值为3

## 强引用和弱引用

引用类型 被垃圾回收的时间 用途 生存时间

强引用 从来不会 对象的一般状态 JVM停止时运行

软引用 内存不足时 对象缓存 内存不足时终止

弱引用 在垃圾回收时 对象缓存 GC运行后终止

## 双亲委派模式优势

采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。可能你会想，如果我们在classpath路径下自定义一个名为java.lang.SingleInterge类(该类是胡编的)呢？该类并不存在java.lang中，经过双亲委托模式，传递到启动类加载器中，由于父类加载器路径下并没有该类，所以不会加载，将反向委托给子类加载器加载，最终会通过系统类加载器加载该类。但是这样做是不允许，因为java.lang是核心API包，需要访问权限，强制加载将会报出如下异常

java.lang.SecurityException: Prohibited package name: java.lang

 
## Java内存模型

1.程序计数器：是一个数据结构，用于保存当前正常执行的程序的内存地址。Java虚拟机的多线程就是通过线程轮流切换并分配处理器时间来实现的， 为了线程切换后能恢复到正确的位置，每条线程都需要一个独立的程序计数器，互不影响，该区域为“线程私有”。

2.Java虚拟机栈：线程私有的，与线程生命周期相同，用于存储局部变量表，操作栈，方法返回值。局部变量表放着基本数据类型，还有对象的引用。

3.本地方法栈：跟虚拟机栈很像，不过它是为虚拟机使用到的Native方法服务。hashcode方法是native的.wait(long times) notify  notifyAll也是native的

4.Java堆：所有线程共享的一块内存区域，对象实例几乎都在这分配内存。

5.方法区：各个线程共享的区域，储存虚拟机加载的类信息，常量，静态变量，编译后的代码。

6.运行时常量池：代表运行时每个class文件中的常量表。包括几种常量：编译时的数字常量、方法或者域的引用。

## 垃圾回收

新生代：复制算法     老年代：标记清除、标记整理

引用计数法   可达性算法

在java中可以作为GC Roots的对象有以下几种：

1.虚拟机栈中引用的对象、

2.方法区类静态属性引用的对象、

3.方法区常量池引用的对象、

4.本地方法栈JNI引用的对象

### GC的触发条件
youngGC的eden区满则触发youngGC，将eden区和一个servivor区存活的对象分配到另一个servivor区。
第一次youngGC是将eden区存活的内存分到其中一个servivor分区
默认15次youngGC还没被回收就会进入老年代,对象很大也会直接进入老年代

 
老生代回收用广度   占用内存大点，但是速度快点
新生代回收用深度    深度优先算法占内存少，因为有回溯，但移动较慢

java 1.8 永久代消失了，由元空间取代

Eclipse内存泄露 MAT

Intelij Idea内存泄漏   JProfiler

### JVM垃圾回收器
因为和用户线程一起执行，不能在空间将满时再清理。
 -XX:CMSInitiatingOccupancyFraction设置触发GC的阈值。 设定老年代空间被使用多少后触发。
 如果不幸内存预留空间不足，就会引起concurrent mode failure.
在CMS遇到空间不足时，可以使用串行收集器作为后备。
 

## JVM调优

-Xms  初始堆大小

-Xmx  最大堆大小

-Xmn  年轻代大小

 

-XX:NewSize  设置年轻代大小


-XX:+PrintGCDetails   打印出GC信息

### 线上CPU100%排查
1.jps查看进程号
jps(Java Virtual Machine Process Status Tool)
jps主要用来输出JVM中运行的进程状态信息。
2.top -Hp pid可以查看某个进程的线程信息
-H 显示线程信息，-p指定pid
printf "%x\n" 8600 
jstack 8591|grep 2198

排查内存溢出
jmap可以打印dump文件，打印出来以后，可以用jprofiler或者mat来看


### jvm的一些工具
jstack主要用来查看某个Java进程内的线程堆栈信息。
jstat主要是 jvm相关的一些信息
jmap  生成存储快照