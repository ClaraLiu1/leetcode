# Table of Contents

  * [http状态码](#http状态码)
  * [网络分层](#网络分层)
  * [TCP和UDP](#tcp和udp)
  * [TCP的可靠性如何保证：](#tcp的可靠性如何保证：)
  * [TCP三次握手和四次挥手](#tcp三次握手和四次挥手)
  * [time_wait状态产生的原因，危害，如何避免](#time_wait状态产生的原因，危害，如何避免)
  * [为什么不能采用两次握手:](#为什么不能采用两次握手)
  * [浏览器输入www.baidu.com相应全过程](#浏览器输入wwwbaiducom相应全过程)
    * [四层负载均衡和七层负载均衡](#四层负载均衡和七层负载均衡)
    * [[HTTP与TCP的区别和联系](https://blog.csdn.net/reed1991/article/details/53121009)](#[http与tcp的区别和联系]httpsblogcsdnnetreed1991articledetails53121009)
    * [HTTP1.0 HTTP 1.1 HTTP 2.0主要区别](#http10-http-11-http-20主要区别)


## http状态码

2xx （成功）表示成功处理了请求的状态码。

3xx （重定向） 要完成请求，需要进一步操作。通常，这些状态码用来重定向。

4xx（请求错误） 这些状态码表示请求可能出错，妨碍了服务器的处理。

5xx（服务器错误）这些状态码表示服务器在处理请求时发生内部错误

## 网络分层

七层：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层

四层：网络接口层、网际层、运输层、应用层

五层：物理层、数据链路层、网络层、运输层、应用层

## TCP和UDP
                
 对比项             TCP                 UDP

传输单位             报文               用户数据包

是否连接           面向连接               面向非连接

传输可靠性          可靠                不可靠

应用场合         传输大量数据           传输少量数据


## TCP的可靠性如何保证：

在TCP的连接中，数据流必须以正确的顺序送达对方。TCP的可靠性是通过顺序编号和确认（ACK）来实现的。

TCP在开始传送一个段时，为准备重传而首先将该段插入到发送队列之中，同时启动时钟。

其后，如果收到了接受端对该段的ACK信息，就将该段从队列中删去。

如果在时钟规定的时间内，ACK未返回，那么就从发送队列中再次送出这个段。

TCP在协议中就对数据可靠传输做了保障，握手与断开都需要通讯双方确认，数据传输也需要双方确认成功，在协议中还规定了：分包、重组、重传等规则；而UDP主要是面向不可靠连接的，不能保证数据正确到达目的地。


## TCP三次握手和四次挥手

第一次握手：客户端发送syn包(syn=x)到服务器，并进入SYN_SEND状态，等待服务器确认； 

第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y) 即SYN+ACK包，此时服务器进入SYN_RECV状态；

第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕， 客户端和服务器进入ESTABLISHED状态，完成三次握手。

 

第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方： 我已经不会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文， 主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。

第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。

第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方， 我的数据也发送完了，不会再给你发数据了。

第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。


## time_wait状态产生的原因，危害，如何避免


 

## 为什么不能采用两次握手: 
采用三次握手是为了防止失效的连接请求报文段突然又传送到主机B，因而产生错误。失效的连接请求报文段是指：主机A发出的连接请求没有收到主机B的确认，于是经过一段时间后，主机A又重新向主机B发送连接请求，且建立成功，顺序完成数据传输。考虑这样一种特殊情况，主机A第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机B，主机B以为是主机A又发起的新连接，于是主机B同意连接，并向主机A发回确认，但是此时主机A根本不会理会，主机B就一直在等待主机A发送数据，导致主机B的资源浪费。

## 浏览器输入www.baidu.com相应全过程

1.客户端浏览器通过DNS解析到www.baidu.com的IP地址为220.181.0.1，通过这个ip地址找到客户端到服务器的路径，客户端浏览器发起一个http会话到220.181.0.1，然后通过TCP进行封装数据包，输入到网络层。

2.在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器端用80端口监听客户端的请求，客户端由系统随机选择一个端口，如5000，与客户端进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用ip层的ip地址查找目的端。

3.客户端的网络层不用关心应用层和传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器。

4.客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定的ip地址和MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的ip数据包现在就可以传输了，然后发送Ip数据包到达服务器的地址。

[一个页面从输入URL到页面加载显示完成，这个过程都发生什么？](https://blog.csdn.net/reed1991/article/details/53791010)


### 四层负载均衡和七层负载均衡
四层负载均衡工作在OSI模型的传输层，由于在传输层，只有TCP/UDP协议，这两种协议中除了包含源IP、目标IP以外，还包含源端口号及目的端口号。四层负载均衡服务器在接受到客户端请求后，以后通过修改数据包的地址信息（IP+端口号）将流量转发到应用服务器。

七层负载均衡工作在OSI模型的应用层，应用层协议较多，常用http、radius、dns等。七层负载就可以基于这些协议来负载。这些应用层协议中会包含很多有意义的内容。比如同一个Web服务器的负载均衡，除了根据IP加端口进行负载外，还可根据七层的URL、浏览器类别、语言来决定是否要进行负载均衡。

### [HTTP与TCP的区别和联系](https://blog.csdn.net/reed1991/article/details/53121009)


### HTTP1.0 HTTP 1.1 HTTP 2.0主要区别
 HTTP1.0 HTTP 1.1主要区别
 1.长连接：HTTP 1.0需要使用keep-alive参数来告知服务器端要建立一个长连接，而HTTP1.1默认支持长连接。
 2.HOST域： 现在可以web server例如tomat，设置虚拟站点是非常常见的，也即是说，web server上的多个虚拟站点可以共享同一个ip和端口。
 HTTP1.0是没有host域的，HTTP1.1才支持这个参数。
 HTTP1.1 HTTP 2.0主要区别
 多路复用
 1.HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。
 2.数据压缩HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。
 服务器推送
 
## Get和Post的区别
Get是从服务器上获得数据，而Post则是向服务器传递数据的。
Get是不安全的，很可能你的一些操作会被第三方看到，而Post的所有操作多用户来说是不可见的。
Get传输的数据量小，主要是因为它受约于URL长度的限制，而Post可以传输大量的数据，所以我们在传文件的时候会用Post。

