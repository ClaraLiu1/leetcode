# Table of Contents

  * [进程与线程](#进程与线程)
  * [进程间的通信方式：](#进程间的通信方式：)
  * [线程间通信的方式?](#线程间通信的方式)
  * [Java线程间的通信方式：](#java线程间的通信方式：)
  * [产生死锁的四个必要条件：](#产生死锁的四个必要条件：)
  * [阻塞和非阻塞，同步和异步](#阻塞和非阻塞，同步和异步)
  * [CPU密集型和IO密集型](#cpu密集型和io密集型)


## 进程与线程
进程是资源管理的最小单位，线程是程序执行的最小单位，所以java中cpu调度的是进程。
进程有独立的地址空间，   线程的堆空间是共享的，栈空间是独立的，
一个进程拥有一个或者多个线程
线程比进程更小，线程花费更少的cpu资源。

## 进程间的通信方式：

1.共享内存:可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存 空间,不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式 需要依靠某种同步操作,如互斥锁和信号量等。

2.消息队列:是在消息的传输过程中保存消息的容器。具有写权限得进程可 以按照一定得规则向消息队列中添加新信息;对消息队列有读权限得进程则可 以从消息队列中读取信息。

3.信号:信号是一种比较复杂的通信方式,用于通知接收进程某个事件已经发生。

4.信号量:信号量是一个计数器,可以用来控制多个进程对共享资源的访问。它常作 为一种锁机制,防止某进程正在访问共享资源时,其他进程也访问该资源。因 此,主要作为进程间以及同一进程内不同线程之间的同步手段。

5.套接字:这是一种更为一般得进程间通信机制,它可用于网络中不同机器之间的进程 间通信,应用非常广泛。

6.普通管道:普通管道是一种半双工的通信方式,数据只能单向流动,而且只能在具有 父子关系的进程间使用。

7.有名管道:有名管道也是半双工的通信方式,但是它允许无亲缘关系进程间的通信。

## 进程的调度算法有哪些？

1.先来先服务（FCFS）:此算法的原则是按照作业到达后备作业队列（或进程进入就绪队列）的先后次序选择作业（或进程）
2.短作业优先（SJF:Shortest Process First）：这种算法主要用于作业调度，它从作业后备序列中挑选所需运行时间最短的作业进入主存运行。
3.时间片轮转调度算法：当某个进程执行的时间片用完时，调度程序便终止该进程的执行，并将它送到就绪队列的末尾，等待分配下一时间片再执行。然后把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。这样就可以保证队列中的所有进程，在已给定的时间内，均能获得一时间片处理机执行时间。
4.高响应比优先：按照高响应比（已等待时间+要求运行时间）/要求运行时间 优先的原则，在每次选择作业投入运行时，先计算此时后备作业队列中每个作业的响应比RP。选择最大的作业投入运行。
5.优先权调度算法：按照进程的优先权大小来调度。使高优先权进程得到优先处理的调度策略称为优先权调度算法。注意：优先数越多，优先权越小。
6.多级队列调度算法：多队列调度是根据作业的性质和类型的不同，将就绪队列再分为若干个队列，所有的作业（进程）按其性质排入相应的队列中，而不同的就绪队列采用不同的调度算法。



## 线程间通信的方式?

    锁机制:包括互斥锁、读写锁、条件变量
        互斥锁提供了以排他方式防止数据结构被并发修改的方法。
        读写锁允许多个线程同时读共享数据,而对写操作是互斥的。
        条件变量可以以原子的方式阻塞进程,直到某个特定条件为真为止。对条 件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。

    信号量机制(Semaphore):包括无名线程信号量和命名线程信号量。

    信号机制(Signal):类似进程间的信号处理。

     线程间的通信目的主要是用于线程同步,所以线程没有像进程通信中的用 于数据交换的通信机制。

## 分段和分页的区别？

1、页是信息的物理单位，分页是为了实现离散分配方式，以减少内存的外零头，提高内存的利用率。分页仅仅是由于系统管理的需要，而不是用户的需要。
2、段是信息的逻辑单位，它含有一组其意义相对完整的信息。分段的目的是为了能更好的满足用户的需要。
3、页的大小固定且由系统确定，把逻辑地址分为页号和页内地址两部分，由机器硬件实现的。因此一个系统只能有一种大小的页面。段的长度却不固定，决定于用户所编写的程序，通常由编写程序在对源代码进行编辑时，根据信息的性质来划分。
4、分页的作业地址空间是一维的，即单一的线性空间。
5、分段的作业地址空间是二维的，程序员在标识一个地址时，既需要给出段名，又需要给出段内地址。



## Java线程间的通信方式：
while轮询、 wait notify机制、 同步synchronized共享存储

## 产生死锁的四个必要条件：
（1） 互斥条件：一个资源每次只能被一个进程使用。
（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
（3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。
（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

银行家算法：避免死锁
资源有序分配法：预防死锁
资源分配图化简法：检测死锁

撤销进程法：解决死锁

## 阻塞和非阻塞，同步和异步
同步和异步是相对于操作结果来说，会不会等待结果返回。
阻塞和非阻塞是指进程访问的数据如果尚未就绪，进程是否需要等待

[阻塞和非阻塞，同步和异步](https://blog.csdn.net/reed1991/article/details/53165005)


## CPU密集型和IO密集型
CPU密集型，计算比较多
IO密集型，磁盘的读写操作比较多
[CPU密集型和IO密集型](https://blog.csdn.net/reed1991/article/details/53900628)

