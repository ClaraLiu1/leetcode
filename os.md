# Table of Contents

  * [进程与线程](#进程与线程)
  * [进程间的通信方式：](#进程间的通信方式：)
  * [线程间通信的方式?](#线程间通信的方式)
  * [Java线程间的通信方式：](#java线程间的通信方式：)
  * [产生死锁的四个必要条件：](#产生死锁的四个必要条件：)
  * [阻塞和非阻塞，同步和异步](#阻塞和非阻塞，同步和异步)
  * [CPU密集型和IO密集型](#cpu密集型和io密集型)


## 进程与线程
进程是资源管理的最小单位，线程是程序执行的最小单位，
进程有独立的地址空间，   线程的堆空间是共享的，栈空间是独立的，
一个进程拥有一个或者多个线程
线程比进程更小，线程花费更少的cpu资源。

## 进程间的通信方式：

1.共享内存:可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存 空间,不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式 需要依靠某种同步操作,如互斥锁和信号量等。

2.消息队列:是在消息的传输过程中保存消息的容器。具有写权限得进程可 以按照一定得规则向消息队列中添加新信息;对消息队列有读权限得进程则可 以从消息队列中读取信息。

3.信号:信号是一种比较复杂的通信方式,用于通知接收进程某个事件已经发生。

4.信号量:信号量是一个计数器,可以用来控制多个进程对共享资源的访问。它常作 为一种锁机制,防止某进程正在访问共享资源时,其他进程也访问该资源。因 此,主要作为进程间以及同一进程内不同线程之间的同步手段。

5.套接字:这是一种更为一般得进程间通信机制,它可用于网络中不同机器之间的进程 间通信,应用非常广泛。

6.普通管道:普通管道是一种半双工的通信方式,数据只能单向流动,而且只能在具有 父子关系的进程间使用。

7.有名管道:有名管道也是半双工的通信方式,但是它允许无亲缘关系进程间的通信。


## 线程间通信的方式?

    锁机制:包括互斥锁、读写锁、条件变量
        互斥锁提供了以排他方式防止数据结构被并发修改的方法。
        读写锁允许多个线程同时读共享数据,而对写操作是互斥的。
        条件变量可以以原子的方式阻塞进程,直到某个特定条件为真为止。对条 件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。

    信号量机制(Semaphore):包括无名线程信号量和命名线程信号量。

    信号机制(Signal):类似进程间的信号处理。

     线程间的通信目的主要是用于线程同步,所以线程没有像进程通信中的用 于数据交换的通信机制。


## Java线程间的通信方式：
while轮询、 wait notify机制、 同步synchronized共享存储

## 产生死锁的四个必要条件：
（1） 互斥条件：一个资源每次只能被一个进程使用。
（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
（3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。
（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

## 阻塞和非阻塞，同步和异步
同步和异步是相对于操作结果来说，会不会等待结果返回。
阻塞和非阻塞是指进程访问的数据如果尚未就绪，进程是否需要等待

[阻塞和非阻塞，同步和异步](https://blog.csdn.net/reed1991/article/details/53165005)


## CPU密集型和IO密集型
CPU密集型，计算比较多
IO密集型，磁盘的读写操作比较多
[CPU密集型和IO密集型](https://blog.csdn.net/reed1991/article/details/53900628)

